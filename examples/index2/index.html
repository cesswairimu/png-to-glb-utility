<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>png-image-to-glb-formated-file-gen</title>

		<script src="https://cdn.jsdelivr.net/npm/gltf-js-utils/dist/gltfjsutils.js"></script>
		<script src="../../node_modules/jquery/dist/jquery.min.js"></script>
		<script src="../../node_modules/bootstrap/dist/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="../../node_modules/bootstrap/dist/css/bootstrap.min.css">

		<link rel="stylesheet" href="main.css">
	</head>
	<body>
		<div class="container center">
			<h3>PNG image to glb-formated file Generator</h3>
			<br>
			<div class="row">
				<div class="mb-3">
					<label for="formFile" class="form-label" id="img-preview">Default file input example</label>
					<input class="form-control" type="file" id="formFile" accept="image/*">
					<br>
				 <div class="invisible" id="convert-btn">
					 <button type="button" class="btn btn-secondary">Convert to glb</button>
				 </div>
				 <img class="" id="test-image" height="300" width="350" src="../test.png">
				 <img id="uploaded-image" height="300" width="350">
				</div>
			</div>

		
		</div>
		
	
		<script>
			//-----select image code 

			const choseFile =  document.getElementById("formFile");
			const imgPreview = document.getElementById("img-preview");
			let convertBtn = document.getElementById("convert-btn");
			let uploadedSpace =  document.getElementById("uploaded-image");
			let img = document.getElementById("test-image");
			let uploadImg;
			let upload2;
			let upload3;
			


			choseFile.addEventListener("change", function() {
				getImgData();
			})

			function getImgData() {
				const files = choseFile.files[0];
				if (files) {
					const fileReader = new FileReader();
					fileReader.readAsDataURL(files);
					fileReader.addEventListener("load", function(){
						imgPreview.style.display = "block";
						imgPreview.innerHTML = '<img"' + this.result +'" />';
						uploadImg = this.result;
						let url = URL.createObjectURL(files);
						uploadedSpace.src = url;
						upload2 = fileReader.result;
						console.log("---inside getimg data");
						console.log(imgPreview);
						console.log(url);
						console.log(uploadedSpace);
						//upload3 = fileReader;
						convertBtn.classList.remove('invisible');
										});
				}

			
			}



			//---------end of image upload


			// -------creating a GLFT Asset

			convertBtn.addEventListener("click", function(){
				createGLFTAsset();

			});

			let gltfFiles;
			async function createGLFTAsset(){
				console.log("creating a GLFT Asset---")

			  let asset = new  GLTFUtils.GLTFAsset({"number": 0, "index": 0});
				let scene = new GLTFUtils.Scene("");
				asset.addScene(scene);

				// create a node
				let node = new GLTFUtils.Node();
				// node.setTranslation(0, 0, 0);
				// node.setRotationRadians(0, 0, 0);
				// node.setScale(1, 1, 1);
				//console.log(node);
				scene.addNode(node);
				console.log(scene);


				// add vertices
				const vertices = [1,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,1,0];
				//const vertices = [1,0,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,0,1,0];


				let v1;
				let v2;
				let v3;

        let vertex_hash = [];
        for (let i = 0; i < vertices.length; i += 3) {
					const vertex = new GLTFUtils.Vertex();
					vertex.x = vertices[i];
					vertex.y = [i + 1];
					vertex.z = vertices[i + 2];
					vertex_hash.push(vertex);
				}
				var triangles = [0,1,2,2,3,0,4,5,1,1,0,4,6,7,5,5,4,6,3,2,7,7,6,3,7,1,5,7,2,1,4,0,6,0,3,6];
				
				const mesh = new GLTFUtils.Mesh();

				const material = new GLTFUtils.Material();
				console.log('image ----' +img.src);
				console.log('image uploaded ----' +uploadImg);
			  console.log("upload2 -----" +upload2); // same as above
			 console.log("attempt to extract data uri -----");

			 upload3 = dataURItoBlob(uploadImg);
			console.log("upload3 -----" +upload3);
			 //console.log("upload3 -----" +upload3);




				//const texture = new GLTFUtils.Texture(img.src); // HTMLImageElement
				//texture.wrapS = GLTFUtils.WrappingMode.CLAMP_TO_EDGE;
				//texture.wrapT = GLTFUtils.WrappingMode.REPEAT;
				//material.pbrMetallicRoughness.baseColorTexture = texture;
				// material.texture = texture;

				//const material = new GLTFUtils.Material(img);
				
      //   for (let i = 0; i < triangles.length; i += 3) {
      //   v1 = vertex_hash[triangles[i]];
      //   v2 = vertex_hash[triangles[i + 1]];
      //   v3 = vertex_hash[triangles[i + 2]];
			// 	mesh.addFace(v1, v2, v3, {r: 1, g: 1, b: 1}, 0);
			// }


			// RSC---update
			//material.pbrMetallicRoughness =material
			//material.baseColorTexture = texture;


			/// --- end of update 




			// RSC---update


			/// --- end of update


				// const material = new GLTFUtils.Material();
				///---texture ---//
				const texture = new GLTFUtils.Texture(uploadedSpace);
				// const texture = new GLTFUtils.Texture(uploadImg); // HTMLImageElement
			//	const texture = new GLTFUtils.Texture(img); // HTMLImageElement
				texture.wrapS = GLTFUtils.WrappingMode.CLAMP_TO_EDGE;
				texture.wrapT = GLTFUtils.WrappingMode.REPEAT;
				material.pbrMetallicRoughness.baseColorTexture = texture;
				material.texture = texture;
				mesh.material = [material];
				node.mesh = mesh;



				// const mesh = new GLTFUtils.Mesh();
				// const vertices = [
				// new GLTFUtils.Vertex(0, 0, 0),
				//  new GLTFUtils.Vertex(1, 0, 0),
				//  new GLTFUtils.Vertex(1, 1, 0),
				//  new GLTFUtils.Vertex(0, 1, 0)
				// ];
		    //mesh.vertices = vertices;
		    //console.log("vertices added" +mesh);
				
	
				
				//mesh.material = [material];
				//node.mesh =mesh;
				//console.log(mesh);


				console.log(node);
				console.log(mesh);
				console.log("the material");
				console.log(material);
				console.log("final mesh" + mesh);
				console.log(scene);

				// export asset as glb
				// const glbFiles =  GLTFUtils.exportGLB(asset);
				const glbFiles = downloadGlb(asset);
				console.log("glb-formatted---");
				console.log(glbFiles);
				console.log("----asset----");
				console.log(asset);


				
				// export asset as  gltf
				// gltfFiles = GLTFUtils.exportGLTF(asset);
				gltfFiles = downloadGltf(asset);


				// export glft with data uri
				const object = await GLTFUtils.exportGLTF(asset, {
					bufferOutputType: GLTFUtils.BufferOutputType.DataURI,
					imageOutputType: GLTFUtils.BufferOutputType.DataURI,
				});
				console.log("object---")
				console.log(object);


//------ 4th Edit ------------------- //
				// plain file txt
			var element = document.createElement('a');
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(JSON.stringify(asset)));
			element.setAttribute('download', "test.gltf");
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);


			///  glb download
			// const link = document.createElement("a");
			// link.href = window.URL.createObjectURL(glbFiles);
			// link.download = "test.glb";
			// link.click();

			


			// // gltf download
			// const link1 = document.createElement("a");
			// const url  = window.URL.createObjectURL(new Blob([gltfFiles]));
			// link1.href = url;
			// link1.download = "test.gltf";
			// link1.click();




				
	// ----- end of 4th Edit ------------------- //

			
			

				console.log("glft-formatted---");
				console.log(gltfFiles);
				console.log(JSON.stringify(gltfFiles));
				// return gltfFiles  + glbFiles;

				

			}
			
			//---------------end of GLFT section

			async function downloadGltf(asset){
				let files = await GLTFUtils.exportGLTF(asset);;
				return files;

			}

			async function downloadGlb(asset){
			let files = await GLTFUtils.exportGLB(asset);
			return files;
			}

			// convert base64/URLEncoded data component to raw binary data held in a string

			function dataURItoBlob(dataURI) {
        var byteString;
       if (dataURI.split(',')[0].indexOf('base64') >= 0)
        byteString = atob(dataURI.split(',')[1]);
    else
        byteString = unescape(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to a typed array
    var ia = new Uint8Array(byteString.length);
    for (var i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }

    return new Blob([ia], {type:mimeString});
}

		</script>


</body>
</html>
